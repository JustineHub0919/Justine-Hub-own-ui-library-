-- Kaze UI (tabs-first focused, fixes for: table-title, locked tabs, mobile+pc dragging)
local Kaze_UI = {}
Kaze_UI.__index = Kaze_UI

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local LP = Players.LocalPlayer

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "KazeUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = LP:WaitForChild("PlayerGui")

local UIScale = Instance.new("UIScale")
UIScale.Parent = ScreenGui
local function UpdateScale()
	local size = workspace.CurrentCamera.ViewportSize
	if size.X < 600 then
		UIScale.Scale = math.clamp(size.X / 800, 0.5, 1)
	else
		UIScale.Scale = math.clamp(size.X / 1920, 0.6, 1)
	end
end
UpdateScale()
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(UpdateScale)

local function FormatImage(id)
	if not id then return "" end
	id = tostring(id)
	local clean = string.gsub(id, "%D", "")
	if clean == "" then return "" end
	return "rbxassetid://" .. clean
end

local function AnimateStrokeColor(stroke)
	spawn(function()
		while stroke and stroke.Parent do
			local ok, tween = pcall(function()
				return TweenService:Create(stroke, TweenInfo.new(1.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Color = Color3.fromRGB(0, 255, 255)})
			end)
			if ok and tween then tween:Play() end
			break
		end
	end)
end

-- Robust draggable: pointer offset, Active=true, clamp on release (works for touch & mouse)
local function MakeDraggable(dragPart, targetPart)
	if not dragPart or not targetPart then return end
	pcall(function() dragPart.Active = true end)
	pcall(function() targetPart.Active = true end)

	local dragging = false
	local dragInput = nil
	local pointerOffset = nil

	local function clampAbsolutePosition(absPos, absSize)
		local ok, vp = pcall(function() return workspace.CurrentCamera.ViewportSize end)
		if not ok or not vp then return absPos end
		local minX, minY = 0, 0
		local maxX = math.max(0, vp.X - absSize.X)
		local maxY = math.max(0, vp.Y - absSize.Y)
		local clampedX = math.clamp(absPos.X, minX, maxX)
		local clampedY = math.clamp(absPos.Y, minY, maxY)
		return Vector2.new(clampedX, clampedY)
	end

	local function setPositionFromAbsolute(gui, absPos)
		local anchor = gui.AnchorPoint or Vector2.new(0, 0)
		local size = gui.AbsoluteSize
		local newX = absPos.X - (size.X * anchor.X)
		local newY = absPos.Y - (size.Y * anchor.Y)
		gui.Position = UDim2.new(0, math.floor(newX + 0.5), 0, math.floor(newY + 0.5))
	end

	local function onUpdate(input)
		if not dragging or not pointerOffset then return end
		if not input or not input.Position then return end
		local newAbs = input.Position - pointerOffset
		local clamped = clampAbsolutePosition(newAbs, targetPart.AbsoluteSize)
		setPositionFromAbsolute(targetPart, clamped)
	end

	dragPart.InputBegan:Connect(function(input)
		if not input then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if not targetPart.Visible then return end
			dragging = true
			dragInput = input
			local startAbs = targetPart.AbsolutePosition
			pointerOffset = input.Position - startAbs

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					dragInput = nil
					if targetPart and targetPart.Parent then
						local finalAbs = targetPart.AbsolutePosition
						local clamped = clampAbsolutePosition(finalAbs, targetPart.AbsoluteSize)
						setPositionFromAbsolute(targetPart, clamped)
					end
				end
			end)
		end
	end)

	dragPart.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	UIS.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			onUpdate(input)
		end
	end)
end

-- Tooltip factory: returns (tipFrame, textLabel). Caller is responsible for parenting & destroying tipFrame.
local function CreateTooltip()
	local tip = Instance.new("Frame")
	tip.Size = UDim2.new(0, 240, 0, 72)
	tip.BackgroundColor3 = Color3.fromRGB(20,20,24)
	tip.BorderSizePixel = 0
	Instance.new("UICorner", tip).CornerRadius = UDim.new(0,8)
	local stroke = Instance.new("UIStroke", tip)
	stroke.Color = Color3.fromRGB(0,160,255)
	stroke.Thickness = 1.5
	AnimateStrokeColor(stroke)

	local txt = Instance.new("TextLabel")
	txt.Size = UDim2.new(1, -16, 1, -16)
	txt.Position = UDim2.fromOffset(8,8)
	txt.BackgroundTransparency = 1
	txt.TextColor3 = Color3.fromRGB(230,230,230)
	txt.TextWrapped = true
	txt.Font = Enum.Font.Gotham
	txt.TextSize = 13
	txt.TextXAlignment = Enum.TextXAlignment.Left
	txt.TextYAlignment = Enum.TextYAlignment.Top
	txt.Parent = tip

	return tip, txt
end

function Kaze_UI:CreateWindow(config)
	config = config or {}
	local OpenIcon = FormatImage((config.OpenButton and config.OpenButton.Icon) or config.Icon or "6031763447")
	local MiniButtonSize = UDim2.fromOffset(60, 60)
	local Callback = config.Callback

	-- Main Window (no top labels â€” focusing on tabs as you requested)
	local Window = Instance.new("Frame")
	Window.Name = "MainWindow"
	Window.AnchorPoint = Vector2.new(0.5,0.5)
	Window.Position = UDim2.fromScale(0.5,0.5)
	Window.BackgroundColor3 = Color3.fromRGB(18,18,20)
	Window.BorderSizePixel = 0
	Window.Parent = ScreenGui
	Window.ClipsDescendants = true
	Instance.new("UICorner", Window).CornerRadius = UDim.new(0,14)

	local WindowStroke = Instance.new("UIStroke")
	WindowStroke.Color = Color3.fromRGB(0,160,255)
	WindowStroke.Thickness = 2.5
	WindowStroke.Parent = Window
	AnimateStrokeColor(WindowStroke)

	local function UpdateWindowSize()
		local vp = workspace.CurrentCamera.ViewportSize
		if vp.X <= 800 or vp.Y <= 600 then
			Window.Size = UDim2.new(0.96, 0, 0.94, 0)
		else
			Window.Size = UDim2.new(0.78, 0, 0.82, 0)
		end
		Window.Position = UDim2.fromScale(0.5,0.5)
	end
	UpdateWindowSize()
	workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(UpdateWindowSize)

	-- TopBar (draggable)
	local TopBar = Instance.new("Frame")
	TopBar.Name = "TopBar"
	TopBar.Size = UDim2.new(1, 0, 0, 56)
	TopBar.BackgroundColor3 = Color3.fromRGB(15,15,20)
	TopBar.BorderSizePixel = 0
	TopBar.Parent = Window
	TopBar.Active = true
	Instance.new("UICorner", TopBar).CornerRadius = UDim.new(0,14)

	MakeDraggable(TopBar, Window)

	-- Content
	local Content = Instance.new("Frame")
	Content.Position = UDim2.fromOffset(0,56)
	Content.Size = UDim2.new(1,0,1,-56)
	Content.BackgroundTransparency = 1
	Content.Parent = Window

	-- Tabs panel (left)
	local TabsPanel = Instance.new("Frame")
	TabsPanel.Name = "TabsPanel"
	TabsPanel.Size = UDim2.new(0, 200, 1, -56)
	TabsPanel.Position = UDim2.new(0, 0, 0, 56)
	TabsPanel.BackgroundColor3 = Color3.fromRGB(12,12,14)
	TabsPanel.BorderSizePixel = 0
	TabsPanel.Parent = Window
	Instance.new("UICorner", TabsPanel).CornerRadius = UDim.new(0,12)

	local TabsStroke = Instance.new("UIStroke")
	TabsStroke.Parent = TabsPanel
	TabsStroke.Color = Color3.fromRGB(0,160,255)
	TabsStroke.Thickness = 2
	TabsStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	AnimateStrokeColor(TabsStroke)

	local TabsList = Instance.new("ScrollingFrame")
	TabsList.Size = UDim2.new(1, -16, 1, -16)
	TabsList.Position = UDim2.fromOffset(8, 8)
	TabsList.BackgroundTransparency = 1
	TabsList.BorderSizePixel = 0
	TabsList.ScrollBarThickness = 8
	TabsList.Parent = TabsPanel
	TabsList.AutomaticCanvasSize = Enum.AutomaticSize.Y

	local TabsLayout = Instance.new("UIListLayout")
	TabsLayout.Parent = TabsList
	TabsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	TabsLayout.Padding = UDim.new(0,8)

	local function updateCanvas()
		TabsList.CanvasSize = UDim2.new(0,0,0, TabsLayout.AbsoluteContentSize.Y + 8)
	end
	TabsLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateCanvas)
	updateCanvas()

	-- Divider & RightContent
	local Divider = Instance.new("Frame")
	Divider.Name = "Divider"
	Divider.Size = UDim2.new(0, 4, 1, -72)
	Divider.Position = UDim2.new(0, 200, 0, 56 + 8)
	Divider.BackgroundColor3 = Color3.fromRGB(0,160,255)
	Divider.Parent = Window
	Instance.new("UICorner", Divider).CornerRadius = UDim.new(0,4)
	local DividerStroke = Instance.new("UIStroke")
	DividerStroke.Parent = Divider
	DividerStroke.Color = Color3.fromRGB(0,160,255)
	DividerStroke.Thickness = 1.6
	AnimateStrokeColor(DividerStroke)

	local RightContent = Instance.new("Frame")
	RightContent.Name = "RightContent"
	RightContent.Size = UDim2.new(1, -200 - 24, 1, -56 - 16)
	RightContent.Position = UDim2.new(0, 200 + 12, 0, 56 + 8)
	RightContent.BackgroundTransparency = 1
	RightContent.Parent = Window

	-- Mini button (draggable)
	local MiniButton = Instance.new("ImageButton")
	MiniButton.Name = "MiniButton"
	MiniButton.Size = MiniButtonSize
	MiniButton.Position = UDim2.fromScale(0.1,0.1)
	MiniButton.BackgroundColor3 = Color3.fromRGB(20,20,25)
	MiniButton.BorderSizePixel = 0
	MiniButton.Visible = false
	MiniButton.Parent = ScreenGui
	MiniButton.ZIndex = 999
	MiniButton.ScaleType = Enum.ScaleType.Slice
	MiniButton.SliceCenter = Rect.new(4,4,60,60)
	MiniButton.Active = true

	local miniUICorner = Instance.new("UICorner"); miniUICorner.CornerRadius = UDim.new(0,12); miniUICorner.Parent = MiniButton
	local miniPadding = Instance.new("UIPadding"); miniPadding.PaddingTop = UDim.new(0,4); miniPadding.PaddingBottom = UDim.new(0,4); miniPadding.PaddingLeft = UDim.new(0,4); miniPadding.PaddingRight = UDim.new(0,4); miniPadding.Parent = MiniButton
	local MiniIcon = Instance.new("ImageLabel"); MiniIcon.Size = UDim2.new(1,0,1,0); MiniIcon.BackgroundTransparency = 1; MiniIcon.Image = OpenIcon; MiniIcon.Parent = MiniButton
	local MiniStroke = Instance.new("UIStroke"); MiniStroke.Color = Color3.fromRGB(0,160,255); MiniStroke.Thickness = 2.5; MiniStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; MiniStroke.Parent = MiniButton; AnimateStrokeColor(MiniStroke)
	MakeDraggable(MiniButton, MiniButton)

	Minimize.MouseButton1Click:Connect(function()
		Window.Visible = false
		MiniButton.Visible = true
		MiniButton.Size = UDim2.fromOffset(0, 0)
		TweenService:Create(MiniButton, TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = MiniButtonSize}):Play()
	end)

	MiniButton.MouseButton1Click:Connect(function()
		MiniButton.Visible = false
		Window.Visible = true
		Window.Size = UDim2.fromOffset(0,0)
		local targetSize
		local vp = workspace.CurrentCamera.ViewportSize
		if vp.X <= 800 or vp.Y <= 600 then
			targetSize = UDim2.new(0.96,0,0.94,0)
		else
			targetSize = UDim2.new(0.78,0,0.82,0)
		end
		local tween = TweenService:Create(Window, TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = targetSize})
		tween:Play()
		tween.Completed:Connect(function() UpdateWindowSize() end)
	end)

	-- Tab engine
	local tabs = {}
	local selectedTab = nil

	local function AddTab(a, b, c, d)
		-- support both AddTab{Title=..., Desc=..., Locked=..., Icon=...} and AddTab(title, desc, locked, icon)
		local def
		if type(a) == "table" and b == nil then
			def = a
		else
			def = {Title = a, Desc = b, Locked = c, Icon = d}
		end
		def = def or {}

		-- if Title is a table (accidental), attempt to extract .Title; otherwise avoid tostring(table)
		local titleText
		if def.Title == nil then
			titleText = "New Tab"
		else
			if type(def.Title) == "table" then
				-- prefer nested Title field if present
				if def.Title.Title then
					titleText = tostring(def.Title.Title)
				else
					titleText = "New Tab"
				end
			else
				titleText = tostring(def.Title)
			end
		end

		local descText
		if def.Desc == nil then
			descText = ""
		else
			if type(def.Desc) == "table" then
				if def.Desc.Desc then
					descText = tostring(def.Desc.Desc)
				else
					descText = ""
				end
			else
				descText = tostring(def.Desc)
			end
		end

		local locked = def.Locked == true
		local icon = def.Icon and FormatImage(def.Icon) or nil

		-- tab frame
		local tabFrame = Instance.new("Frame")
		tabFrame.BackgroundColor3 = Color3.fromRGB(20,20,24)
		tabFrame.Size = UDim2.new(1, 0, 0, 56)
		tabFrame.LayoutOrder = #tabs + 1
		tabFrame.BorderSizePixel = 0
		tabFrame.Parent = TabsList
		Instance.new("UICorner", tabFrame).CornerRadius = UDim.new(0,10)
		tabFrame.Active = true

		local tabStroke = Instance.new("UIStroke")
		tabStroke.Parent = tabFrame
		tabStroke.Color = Color3.fromRGB(0,160,255)
		tabStroke.Thickness = 1.6
		tabStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		AnimateStrokeColor(tabStroke)

		local iconLabel = Instance.new("ImageLabel")
		iconLabel.Size = UDim2.fromOffset(34,34)
		iconLabel.Position = UDim2.fromOffset(10,11)
		iconLabel.BackgroundTransparency = 1
		iconLabel.Image = icon or ""
		iconLabel.Parent = tabFrame
		Instance.new("UICorner", iconLabel).CornerRadius = UDim.new(1,0)

		local titleLabel = Instance.new("TextLabel")
		titleLabel.Size = UDim2.new(1, -70, 0, 24)
		titleLabel.Position = UDim2.fromOffset(54, 6)
		titleLabel.BackgroundTransparency = 1
		titleLabel.Text = titleText
		titleLabel.TextColor3 = Color3.fromRGB(230,230,230)
		titleLabel.Font = Enum.Font.GothamBold
		titleLabel.TextSize = 14
		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
		titleLabel.TextWrapped = false
		titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
		titleLabel.Parent = tabFrame

		local descLabel = Instance.new("TextLabel")
		descLabel.Size = UDim2.new(1, -70, 0, 18)
		descLabel.Position = UDim2.fromOffset(54, 28)
		descLabel.BackgroundTransparency = 1
		descLabel.Text = descText
		descLabel.TextColor3 = Color3.fromRGB(160,160,160)
		descLabel.Font = Enum.Font.Gotham
		descLabel.TextSize = 12
		descLabel.TextXAlignment = Enum.TextXAlignment.Left
		descLabel.TextWrapped = false
		descLabel.TextTruncate = Enum.TextTruncate.AtEnd
		descLabel.Parent = tabFrame

		local selIndicator = Instance.new("Frame")
		selIndicator.Size = UDim2.new(0,6,1,0)
		selIndicator.Position = UDim2.new(0,0,0,0)
		selIndicator.BackgroundColor3 = Color3.fromRGB(0,220,180)
		selIndicator.Visible = false
		selIndicator.Parent = tabFrame
		Instance.new("UICorner", selIndicator).CornerRadius = UDim.new(0,4)

		-- lock label text (emoji) created only if locked
		local lockLabel
		local function ensureLock()
			if lockLabel then return end
			lockLabel = Instance.new("TextLabel")
			lockLabel.Size = UDim2.fromOffset(18,18)
			lockLabel.AnchorPoint = Vector2.new(1,0)
			lockLabel.Position = UDim2.new(1, -10, 0, 19)
			lockLabel.BackgroundTransparency = 1
			lockLabel.Text = "ðŸ”’"
			lockLabel.TextSize = 16
			lockLabel.Font = Enum.Font.SourceSans
			lockLabel.TextColor3 = Color3.fromRGB(200,200,200)
			lockLabel.Parent = tabFrame
		end
		if locked then ensureLock() end

		local tabContent = Instance.new("Frame")
		tabContent.Size = UDim2.new(1,0,1,0)
		tabContent.BackgroundTransparency = 1
		tabContent.Visible = false
		tabContent.Parent = RightContent

		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(1,0,1,0)
		btn.BackgroundTransparency = 1
		btn.Text = ""
		btn.Parent = tabFrame

		-- selection uses closure local 'locked' variable (safe) instead of referencing returned object
		local function select()
			if locked then
				local ok, pulse = pcall(function()
					return TweenService:Create(tabStroke, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Thickness = 3})
				end)
				if ok and pulse then
					pulse:Play()
					pulse.Completed:Connect(function() pcall(function() tabStroke.Thickness = 1.6 end) end)
				end
				return
			end
			if selectedTab and selectedTab.selIndicator then
				selectedTab.selIndicator.Visible = false
				selectedTab.tabFrame.BackgroundColor3 = Color3.fromRGB(20,20,24)
				selectedTab.tabContent.Visible = false
			end
			selIndicator.Visible = true
			tabFrame.BackgroundColor3 = Color3.fromRGB(28,28,32)
			tabContent.Visible = true
			selectedTab = {tabFrame = tabFrame, tabContent = tabContent, selIndicator = selIndicator, titleLabel = titleLabel}
		end

		btn.MouseButton1Click:Connect(select)

		-- tooltip description (hover on PC / long-press on mobile)
		local tooltip, tooltipText = CreateTooltip()
		local tooltipActive = false
		local longPressTask = nil

		tabFrame.MouseEnter:Connect(function()
			if UIS.TouchEnabled then return end
			if descText == "" then return end
			if tooltipActive then return end
			tooltipText.Text = descText
			tooltip.Parent = ScreenGui
			local pos = tabFrame.AbsolutePosition + Vector2.new(tabFrame.AbsoluteSize.X + 8, tabFrame.AbsoluteSize.Y/2)
			local x = math.clamp(pos.X, 8, workspace.CurrentCamera.ViewportSize.X - tooltip.AbsoluteSize.X - 8)
			local y = math.clamp(pos.Y - tooltip.AbsoluteSize.Y/2, 8, workspace.CurrentCamera.ViewportSize.Y - tooltip.AbsoluteSize.Y - 8)
			tooltip.Position = UDim2.new(0, x, 0, y)
			tooltipActive = true
		end)
		tabFrame.MouseLeave:Connect(function()
			if tooltipActive and tooltip and tooltip.Parent then tooltip:Destroy() end
			tooltipActive = false
		end)

		tabFrame.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.Touch and descText ~= "" then
				-- long press
				longPressTask = task.spawn(function()
					task.wait(0.5)
					if input.UserInputState == Enum.UserInputState.Begin then
						tooltipText.Text = descText
						tooltip.Parent = ScreenGui
						local pos = input.Position
						local x = math.clamp(pos.X, 8, workspace.CurrentCamera.ViewportSize.X - tooltip.AbsoluteSize.X - 8)
						local y = math.clamp(pos.Y - tooltip.AbsoluteSize.Y/2, 8, workspace.CurrentCamera.ViewportSize.Y - tooltip.AbsoluteSize.Y - 8)
						tooltip.Position = UDim2.new(0, x, 0, y)
						tooltipActive = true
					end
				end)
			end
		end)
		tabFrame.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.Touch then
				-- hide tooltip if shown
				if tooltipActive and tooltip and tooltip.Parent then tooltip:Destroy() end
				tooltipActive = false
				longPressTask = nil
			end
		end)

		-- keep lock icon positioned on resize
		tabFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			if lockLabel then
				lockLabel.Position = UDim2.new(1, -10, 0, 19)
			end
		end)

		-- returned object: methods operate on closures, safe
		local tabObj = {
			tabFrame = tabFrame,
			titleLabel = titleLabel,
			descLabel = descLabel,
			icon = iconLabel,
			tabContent = tabContent,
			select = select,
			setTitle = function(newTitle)
				if newTitle == nil then return end
				if type(newTitle) == "table" then
					if newTitle.Title then titleLabel.Text = tostring(newTitle.Title) else titleLabel.Text = "New Tab" end
				else
					titleLabel.Text = tostring(newTitle)
				end
			end,
			setDesc = function(newDesc)
				if newDesc == nil then return end
				if type(newDesc) == "table" then
					if newDesc.Desc then descLabel.Text = tostring(newDesc.Desc) else descLabel.Text = "" end
				else
					descLabel.Text = tostring(newDesc)
				end
			end,
			setLocked = function(state)
				locked = state == true
				if locked then ensureLock() else if lockLabel then lockLabel:Destroy(); lockLabel = nil end end
			end,
			Locked = locked,
			Content = tabContent
		}

		table.insert(tabs, tabObj)
		if #tabs == 1 then tabObj.select() end
		updateCanvas()
		return tabObj
	end

	-- public API
	local api = {
		Window = Window,
		Content = RightContent,
		AddTab = AddTab,
		LeftTabs = {
			Add = AddTab,
			_tabs = tabs,
			Select = function(index)
				if type(index) == "number" and tabs[index] and tabs[index].select then
					tabs[index].select()
				end
			end
		},
		MiniButton = MiniButton,
		_Internals = { TabsPanel = TabsPanel, Divider = Divider }
	}

	if typeof(Callback) == "function" then
		pcall(Callback)
	end

	return api
end

return Kaze_UI
