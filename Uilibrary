-- KazeUI v2 - Performance-focused, edge-case hardened, neon-styled UI
-- Professional, concise comments; optimized for performance and robustness.

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local LP = Players.LocalPlayer

-- Utility (minimal allocations, safe coercions)
local function tostring_safe(v)
	if typeof(v) == "table" then return tostring(v) end
	return tostring(v == nil and "" or v)
end
local function clamp(n, a, b) n = tonumber(n) or 0 if n < a then return a elseif n > b then return b end return n end
local function FormatImage(id)
	if not id then return "" end
	local s = tostring_safe(id)
	local digits = string.gsub(s, "%D", "")
	if digits == "" then return "" end
	return "rbxassetid://" .. digits
end

-- Tween helper (centralized)
local function tween(inst, props, info)
	info = info or TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local t = TweenService:Create(inst, info, props)
	t:Play()
	return t
end

-- Lightweight draggable (no RenderStepped)
local function MakeDraggable(handle, target)
	local dragging, dragInput, dragStart, startPos = false, nil, nil, nil
	local function update(input)
		if not dragStart or not startPos or not target or not target.Parent then return end
		local delta = input.Position - dragStart
		target.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end
	handle.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = target.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					dragInput = nil
				end
			end)
		end
	end)
	handle.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	UIS.InputChanged:Connect(function(input)
		if dragging and input == dragInput then update(input) end
	end)
end

-- Single ScreenGui for session
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "KazeUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = LP:WaitForChild("PlayerGui")

-- Responsive UIScale
local UIScale = Instance.new("UIScale", ScreenGui)
local function UpdateScale()
	local cam = workspace.CurrentCamera
	local size = cam and cam.ViewportSize or Vector2.new(1280,720)
	if size.X < 600 then
		UIScale.Scale = clamp(size.X / 800, 0.48, 0.9)
	else
		UIScale.Scale = clamp(size.X / 1920, 0.6, 1)
	end
end
UpdateScale()
if workspace.CurrentCamera then
	workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(UpdateScale)
end

-- Module
local KazeUI = {}
KazeUI.__index = KazeUI

function KazeUI:CreateWindow(config)
	config = config or {}
	local Title = tostring_safe(config.Title or "Kaze UI")
	local Author = tostring_safe(config.Author or "Unknown")
	local Version = tostring_safe(config.Version or "1.0")
	local MainIcon = FormatImage(config.Icon or "6031763447")
	local OpenIcon = FormatImage((config.OpenButton and config.OpenButton.Icon) or config.Icon or "6031763447")
	local MiniButtonSize = UDim2.fromOffset(60, 60)
	local Callback = config.Callback

	-- Window (root)
	local Window = Instance.new("Frame")
	Window.Name = "KazeUI_Window"
	Window.AnchorPoint = Vector2.new(0.5,0.5)
	Window.Position = UDim2.fromScale(0.5,0.5)
	Window.Size = UDim2.fromOffset(700, 480)
	Window.BackgroundColor3 = Color3.fromRGB(18,18,22)
	Window.BorderSizePixel = 0
	Window.ClipsDescendants = true
	Window.Parent = ScreenGui
	Instance.new("UICorner", Window).CornerRadius = UDim.new(0,14)

	-- Stroke neon (pulsing)
	local WindowStroke = Instance.new("UIStroke", Window)
	WindowStroke.Color = Color3.fromRGB(0,160,255)
	WindowStroke.Thickness = 2
	WindowStroke.Transparency = 0.7
	do
		local info = TweenInfo.new(1.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
		TweenService:Create(WindowStroke, info, {Transparency = 0.15}):Play()
	end

	-- Responsive sizing
	local function AdjustWindowSize()
		local cam = workspace.CurrentCamera
		local size = cam and cam.ViewportSize or Vector2.new(1280,720)
		if size.X <= 600 then
			Window.Size = UDim2.new(0.94, 0, 0.88, 0)
		elseif size.X <= 1280 then
			Window.Size = UDim2.new(0.78, 0, 0.76, 0)
		else
			Window.Size = UDim2.new(0.60, 0, 0.72, 0)
		end
		Window.Position = UDim2.fromScale(0.5, 0.5)
	end
	AdjustWindowSize()
	if workspace.CurrentCamera then
		workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(AdjustWindowSize)
	end

	-- Top bar (draggable)
	local TopBar = Instance.new("Frame", Window)
	TopBar.Name = "TopBar"
	TopBar.Size = UDim2.new(1,0,0,56)
	TopBar.BackgroundColor3 = Color3.fromRGB(15,15,18)
	TopBar.BorderSizePixel = 0
	Instance.new("UICorner", TopBar).CornerRadius = UDim.new(0,14)
	MakeDraggable(TopBar, Window)

	local Icon = Instance.new("ImageLabel", TopBar)
	Icon.Size = UDim2.fromOffset(34,34); Icon.Position = UDim2.fromOffset(12,11); Icon.BackgroundTransparency = 1; Icon.Image = MainIcon
	Instance.new("UICorner", Icon).CornerRadius = UDim.new(1,0)

	local TitleLabel = Instance.new("TextLabel", TopBar)
	TitleLabel.Size = UDim2.new(1,-220,0,22); TitleLabel.Position = UDim2.fromOffset(58,8)
	TitleLabel.BackgroundTransparency = 1; TitleLabel.Text = Title
	TitleLabel.TextColor3 = Color3.fromRGB(235,235,235); TitleLabel.Font = Enum.Font.GothamBold; TitleLabel.TextSize = 16
	TitleLabel.TextXAlignment = Enum.TextXAlignment.Left

	local SubLabel = Instance.new("TextLabel", TopBar)
	SubLabel.Size = UDim2.new(1,-220,0,18); SubLabel.Position = UDim2.fromOffset(58,30)
	SubLabel.BackgroundTransparency = 1; SubLabel.Text = Author .. " | v" .. Version
	SubLabel.TextColor3 = Color3.fromRGB(160,160,160); SubLabel.Font = Enum.Font.Gotham; SubLabel.TextSize = 13
	SubLabel.TextXAlignment = Enum.TextXAlignment.Left

	local Minimize = Instance.new("TextButton", TopBar)
	Minimize.Size = UDim2.fromOffset(36,36); Minimize.Position = UDim2.new(1,-88,0.5,-18)
	Minimize.Text = "—"; Minimize.Font = Enum.Font.GothamBold; Minimize.TextSize = 20
	Minimize.TextColor3 = Color3.fromRGB(220,220,220); Minimize.BackgroundColor3 = Color3.fromRGB(22,22,26)
	Instance.new("UICorner", Minimize).CornerRadius = UDim.new(1,0)

	local Close = Instance.new("TextButton", TopBar)
	Close.Size = UDim2.fromOffset(36,36); Close.Position = UDim2.new(1,-44,0.5,-18)
	Close.Text = "✕"; Close.Font = Enum.Font.GothamBold; Close.TextSize = 18
	Close.TextColor3 = Color3.fromRGB(255,90,90); Close.BackgroundColor3 = Color3.fromRGB(22,22,26)
	Instance.new("UICorner", Close).CornerRadius = UDim.new(1,0)

	-- Main split layout: fixed TabsColumn + PagesHolder
	local MainArea = Instance.new("Frame", Window)
	MainArea.Name = "MainArea"; MainArea.Position = UDim2.fromOffset(0,56); MainArea.Size = UDim2.new(1,0,1,-56); MainArea.BackgroundTransparency = 1

	local TabsColumn = Instance.new("Frame", MainArea)
	TabsColumn.Name = "TabsColumn"; TabsColumn.Position = UDim2.fromOffset(12,12)
	TabsColumn.Size = UDim2.new(0,220,1,-24); TabsColumn.BackgroundColor3 = Color3.fromRGB(18,18,22); TabsColumn.BorderSizePixel = 0
	Instance.new("UICorner", TabsColumn).CornerRadius = UDim.new(0,12)

	local TabsHeader = Instance.new("TextLabel", TabsColumn)
	TabsHeader.Size = UDim2.new(1,-24,0,28); TabsHeader.Position = UDim2.fromOffset(12,8)
	TabsHeader.BackgroundTransparency = 1; TabsHeader.Text = "Tabs"; TabsHeader.Font = Enum.Font.GothamBold; TabsHeader.TextSize = 14
	TabsHeader.TextColor3 = Color3.fromRGB(200,200,200); TabsHeader.TextXAlignment = Enum.TextXAlignment.Left

	local TabsHolder = Instance.new("Frame", TabsColumn)
	TabsHolder.Name = "TabsHolder"; TabsHolder.Position = UDim2.fromOffset(12,40); TabsHolder.Size = UDim2.new(1,-24,1,-52)
	TabsHolder.BackgroundTransparency = 1; TabsHolder.ClipsDescendants = true
	local TabsLayout = Instance.new("UIListLayout", TabsHolder); TabsLayout.SortOrder = Enum.SortOrder.LayoutOrder; TabsLayout.Padding = UDim.new(0,8)

	local PagesHolder = Instance.new("Frame", MainArea)
	PagesHolder.Name = "PagesHolder"; PagesHolder.Position = UDim2.fromOffset(232,12); PagesHolder.Size = UDim2.new(1,-244,1,-24)
	PagesHolder.BackgroundTransparency = 1

	-- Minimized quick button
	local MiniButton = Instance.new("ImageButton", ScreenGui)
	MiniButton.Name = "KazeUI_MiniButton"; MiniButton.Size = MiniButtonSize; MiniButton.Position = UDim2.fromScale(0.1,0.1)
	MiniButton.BackgroundColor3 = Color3.fromRGB(20,20,25); MiniButton.BorderSizePixel = 0; MiniButton.Visible = false; MiniButton.ZIndex = 999
	MiniButton.ScaleType = Enum.ScaleType.Slice; MiniButton.SliceCenter = Rect.new(6,6,54,54)
	Instance.new("UICorner", MiniButton).CornerRadius = UDim.new(0,12)
	local MiniIcon = Instance.new("ImageLabel", MiniButton)
	MiniIcon.Size = UDim2.fromScale(1,1); MiniIcon.BackgroundTransparency = 1; MiniIcon.AnchorPoint = Vector2.new(0.5,0.5); MiniIcon.Position = UDim2.fromScale(0.5,0.5)
	MiniIcon.Image = OpenIcon
	local MiniStroke = Instance.new("UIStroke", MiniButton); MiniStroke.Color = Color3.fromRGB(0,160,255); MiniStroke.Thickness = 2.2; MiniStroke.Transparency = 0.7
	TweenService:Create(MiniStroke, TweenInfo.new(1.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Transparency = 0.15}):Play()
	MakeDraggable(MiniButton, MiniButton)

	-- Minimize/restore (safe state handling)
	Minimize.MouseButton1Click:Connect(function()
		if not Window or not Window.Parent then return end
		Window.Visible = false
		MiniButton.Visible = true
		MiniButton.Size = UDim2.fromOffset(0,0)
		tween(MiniButton, {Size = MiniButtonSize}, TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out))
	end)
	MiniButton.MouseButton1Click:Connect(function()
		if not Window or not Window.Parent then return end
		MiniButton.Visible = false
		Window.Visible = true
		local final = Window.Size
		Window.Size = UDim2.fromOffset(0,0)
		tween(Window, {Size = final}, TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out))
	end)

	-- Close confirmation (simple overlay)
	local function ShowCloseConfirm()
		if not Window or not Window.Parent then return end
		Minimize.Active = false; Close.Active = false
		local Overlay = Instance.new("Frame", Window)
		Overlay.Size = UDim2.new(1,0,1,0); Overlay.Position = UDim2.new(0,0)
		Overlay.BackgroundColor3 = Color3.fromRGB(0,0,0); Overlay.BackgroundTransparency = 0.6; Overlay.ZIndex = 60
		local ConfirmWindow = Instance.new("Frame", Overlay)
		ConfirmWindow.Size = UDim2.fromOffset(360,160); ConfirmWindow.AnchorPoint = Vector2.new(0.5,0.5); ConfirmWindow.Position = UDim2.fromScale(0.5,0.5)
		ConfirmWindow.BackgroundColor3 = Color3.fromRGB(22,22,26)
		Instance.new("UICorner", ConfirmWindow).CornerRadius = UDim.new(0,12)
		local txt = Instance.new("TextLabel", ConfirmWindow)
		txt.Size = UDim2.new(1,-32,0,64); txt.Position = UDim2.fromOffset(16,12); txt.BackgroundTransparency = 1
		txt.Text = "Close the UI?"; txt.Font = Enum.Font.GothamBold; txt.TextSize = 18; txt.TextColor3 = Color3.fromRGB(230,230,230)
		local buttons = Instance.new("Frame", ConfirmWindow)
		buttons.Size = UDim2.new(1,0,0,44); buttons.AnchorPoint = Vector2.new(0,1); buttons.Position = UDim2.new(0,0,1,0); buttons.BackgroundTransparency = 1
		local layout = Instance.new("UIListLayout", buttons); layout.FillDirection = Enum.FillDirection.Horizontal; layout.HorizontalAlignment = Enum.HorizontalAlignment.Center; layout.Padding = UDim.new(0,12)
		local confirm = Instance.new("TextButton", buttons)
		confirm.Size = UDim2.new(0,140,0,36); confirm.BackgroundColor3 = Color3.fromRGB(0,170,255); confirm.Text = "Confirm"; confirm.Font = Enum.Font.GothamBold; confirm.TextSize = 16
		Instance.new("UICorner", confirm).CornerRadius = UDim.new(0,8)
		local cancel = Instance.new("TextButton", buttons)
		cancel.Size = UDim2.new(0,140,0,36); cancel.BackgroundColor3 = Color3.fromRGB(40,40,46); cancel.Text = "Cancel"; cancel.Font = Enum.Font.GothamBold; cancel.TextSize = 16
		Instance.new("UICorner", cancel).CornerRadius = UDim.new(0,8)
		confirm.MouseButton1Click:Connect(function() ScreenGui:Destroy() end)
		cancel.MouseButton1Click:Connect(function() Overlay:Destroy(); Minimize.Active = true; Close.Active = true end)
	end
	Close.MouseButton1Click:Connect(ShowCloseConfirm)

	-- Neon helper: attach UIStroke with initial transparency
	local function ApplyNeon(parent, thickness)
		local s = Instance.new("UIStroke")
		s.Parent = parent
		s.Color = Color3.fromRGB(0,160,255)
		s.Thickness = thickness or 2
		s.Transparency = 0.7
		s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		return s
	end

	-- Tab state
	local tabs = {}
	local activeTab = nil

	-- Activation logic (fast loop-free)
	local function SetActive(tabObj)
		-- Deselect others
		for _, t in ipairs(tabs) do
			if t.Button and t.Button.Parent then
				t.Button.BackgroundColor3 = Color3.fromRGB(28,28,34)
				if t.Stroke then tween(t.Stroke, {Transparency = 0.7}) end
				t.Button.TextColor3 = Color3.fromRGB(220,220,220)
			end
			if t.Content and t.Content.Parent then
				t.Content.Visible = false
			end
		end
		-- Activate requested
		if tabObj and tabObj.Button and tabObj.Button.Parent then
			tabObj.Button.BackgroundColor3 = Color3.fromRGB(0,160,255)
			if tabObj.Stroke then tween(tabObj.Stroke, {Transparency = 0}) end
			tabObj.Button.TextColor3 = Color3.fromRGB(18,18,20)
		end
		if tabObj and tabObj.Content and tabObj.Content.Parent then
			tabObj.Content.Visible = true
		end
		activeTab = tabObj
	end

	-- CreateTab: fixed tabs column; content is a ScrollingFrame that scrolls independently.
	function Window:CreateTab(tabArg, iconArg)
		-- Normalize inputs, safe coercion
		local title, icon = nil, nil
		if typeof(tabArg) == "table" then
			title = tabArg.Name or tabArg.Title or tabArg.Text or tabArg.name or tabArg.title or tabArg.text
			icon = tabArg.Icon or tabArg.Image or tabArg.icon or tabArg.image or iconArg
		else
			title = tabArg
			icon = iconArg
		end
		if not title or title == "" then title = "Tab " .. tostring(#tabs + 1) end
		title = tostring_safe(title)
		local iconImage = FormatImage(icon or "")

		local idx = #tabs + 1

		-- Button in fixed TabsHolder
		local Btn = Instance.new("TextButton")
		Btn.Name = "Kaze_TabButton_" .. tostring(idx)
		Btn.Size = UDim2.new(1, -12, 0, 52)
		Btn.BackgroundColor3 = Color3.fromRGB(28,28,34)
		Btn.BorderSizePixel = 0
		Btn.Text = title
		Btn.TextColor3 = Color3.fromRGB(220,220,220)
		Btn.Font = Enum.Font.GothamBold
		Btn.TextSize = 16
		Btn.Parent = TabsHolder
		Btn.LayoutOrder = idx
		Instance.new("UICorner", Btn).CornerRadius = UDim.new(0,10)

		local BtnIcon = Instance.new("ImageLabel", Btn)
		BtnIcon.Size = UDim2.fromOffset(36,36); BtnIcon.Position = UDim2.fromOffset(8,8); BtnIcon.BackgroundTransparency = 1; BtnIcon.Image = iconImage
		Instance.new("UICorner", BtnIcon).CornerRadius = UDim.new(1,0)

		local pad = Instance.new("UIPadding", Btn); pad.PaddingLeft = UDim.new(0,56)

		-- Neon stroke for active visual
		local stroke = ApplyNeon(Btn)
		stroke.Transparency = 0.7

		-- Hover/press micro-animations (small allocations)
		Btn.MouseEnter:Connect(function() tween(stroke, {Transparency = 0.35}, TweenInfo.new(0.12)) end)
		Btn.MouseLeave:Connect(function() tween(stroke, {Transparency = (activeTab and activeTab.Button == Btn) and 0 or 0.7}, TweenInfo.new(0.12)) end)
		Btn.MouseButton1Down:Connect(function() tween(Btn, {Size = Btn.Size * UDim2.fromScale(0.995,0.995)}, TweenInfo.new(0.06)) end)
		Btn.MouseButton1Up:Connect(function() tween(Btn, {Size = Btn.Size}, TweenInfo.new(0.06)) end)

		-- Content area: ScrollingFrame so only content scrolls (safe AutomaticCanvasSize)
		local Content = Instance.new("ScrollingFrame")
		Content.Name = "Kaze_TabContent_" .. tostring(idx)
		Content.Size = UDim2.new(1,0,1,0)
		Content.Position = UDim2.new(0,0,0,0)
		Content.BackgroundTransparency = 1
		Content.ScrollBarThickness = 8
		Content.AutomaticCanvasSize = Enum.AutomaticSize.Y
		Content.CanvasSize = UDim2.new(0,0,0,0)
		Content.Visible = false
		Content.Parent = PagesHolder

		local padding = Instance.new("UIPadding", Content)
		padding.PaddingTop = UDim.new(0,12); padding.PaddingLeft = UDim.new(0,12); padding.PaddingRight = UDim.new(0,12)

		local layout = Instance.new("UIListLayout", Content)
		layout.SortOrder = Enum.SortOrder.LayoutOrder
		layout.Padding = UDim.new(0,12)
		layout.HorizontalAlignment = Enum.HorizontalAlignment.Center

		-- Update CanvasSize when content changes (efficient: single event)
		layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
			if Content and Content.Parent then
				local sizeY = layout.AbsoluteContentSize.Y
				Content.CanvasSize = UDim2.new(0,0,0, sizeY + 16)
			end
		end)

		-- Tab object
		local tabObj = { Button = Btn, Content = Content, Stroke = stroke }
		table.insert(tabs, tabObj)

		-- Activation binding
		Btn.MouseButton1Click:Connect(function() SetActive(tabObj) end)

		-- Auto-select first tab
		if #tabs == 1 then SetActive(tabObj) end

		-- Element factory methods (all return minimal object/handles)

		function tabObj:CreateButton(txt, callback)
			txt = tostring_safe(txt or "Button")
			local btn = Instance.new("TextButton")
			btn.Size = UDim2.new(1, -24, 0, 44)
			btn.BackgroundColor3 = Color3.fromRGB(20,20,26)
			btn.BorderSizePixel = 0
			btn.Text = txt
			btn.TextColor3 = Color3.fromRGB(235,235,235)
			btn.Font = Enum.Font.GothamBold
			btn.TextSize = 16
			Instance.new("UICorner", btn).CornerRadius = UDim.new(0,8)
			btn.Parent = Content

			local s = ApplyNeon(btn); s.Transparency = 0.8
			btn.MouseEnter:Connect(function() tween(s, {Transparency = 0.25}, TweenInfo.new(0.12)); tween(btn, {Size = btn.Size * UDim2.fromScale(1.004,1.004)}, TweenInfo.new(0.12)) end)
			btn.MouseLeave:Connect(function() tween(s, {Transparency = 0.8}, TweenInfo.new(0.12)); tween(btn, {Size = btn.Size}, TweenInfo.new(0.12)) end)
			btn.MouseButton1Down:Connect(function() tween(btn, {Size = btn.Size * UDim2.fromScale(0.994,0.994)}, TweenInfo.new(0.06)) end)
			btn.MouseButton1Up:Connect(function() tween(btn, {Size = btn.Size}, TweenInfo.new(0.06)) end)
			if typeof(callback) == "function" then btn.MouseButton1Click:Connect(function() pcall(callback) end) end
			return btn
		end

		function tabObj:CreateToggle(txt, default, callback)
			txt = tostring_safe(txt or "Toggle")
			local defaultState = not not default
			local holder = Instance.new("Frame")
			holder.Size = UDim2.new(1, -24, 0, 44); holder.BackgroundTransparency = 1; holder.Parent = Content

			local label = Instance.new("TextLabel", holder)
			label.Size = UDim2.new(1, -64, 1, 0); label.BackgroundTransparency = 1
			label.Text = txt; label.TextColor3 = Color3.fromRGB(230,230,230); label.Font = Enum.Font.Gotham; label.TextSize = 15; label.TextXAlignment = Enum.TextXAlignment.Left

			local toggle = Instance.new("ImageButton", holder)
			toggle.AnchorPoint = Vector2.new(1,0.5); toggle.Position = UDim2.new(1, -12, 0.5, 0)
			toggle.Size = UDim2.new(0,44,0,26); toggle.BackgroundColor3 = Color3.fromRGB(26,26,30); toggle.BorderSizePixel = 0
			Instance.new("UICorner", toggle).CornerRadius = UDim.new(0,14)
			local knob = Instance.new("Frame", toggle)
			knob.Size = UDim2.new(0,22,0,22); knob.Position = UDim2.fromOffset(2,2); knob.BackgroundColor3 = Color3.fromRGB(230,230,230); knob.BorderSizePixel = 0
			Instance.new("UICorner", knob).CornerRadius = UDim.new(1,0)

			local s = ApplyNeon(toggle); s.Transparency = defaultState and 0 or 0.8
			local enabled = defaultState

			local function Set(v)
				enabled = not not v
				if enabled then
					tween(knob, {Position = UDim2.new(1, -24, 0, 2)}, TweenInfo.new(0.14))
					tween(toggle, {BackgroundColor3 = Color3.fromRGB(0,160,255)}, TweenInfo.new(0.14))
					tween(s, {Transparency = 0}, TweenInfo.new(0.14))
				else
					tween(knob, {Position = UDim2.fromOffset(2,2)}, TweenInfo.new(0.14))
					tween(toggle, {BackgroundColor3 = Color3.fromRGB(26,26,30)}, TweenInfo.new(0.14))
					tween(s, {Transparency = 0.8}, TweenInfo.new(0.14))
				end
				if typeof(callback) == "function" then pcall(callback, enabled) end
			end

			toggle.MouseButton1Click:Connect(function() Set(not enabled) end)
			Set(enabled)

			return { Frame = holder, Set = Set, Get = function() return enabled end }
		end

		function tabObj:CreateSlider(txt, min, max, default, callback)
			txt = tostring_safe(txt or "Slider")
			min = tonumber(min) or 0; max = tonumber(max) or 100
			if max <= min then max = min + 1 end
			default = clamp(tonumber(default) or min, min, max)

			local holder = Instance.new("Frame")
			holder.Size = UDim2.new(1, -24, 0, 64); holder.BackgroundTransparency = 1; holder.Parent = Content

			local label = Instance.new("TextLabel", holder)
			label.Size = UDim2.new(1, -16, 0, 18); label.Position = UDim2.fromOffset(0,0); label.BackgroundTransparency = 1
			label.Text = txt; label.TextColor3 = Color3.fromRGB(230,230,230); label.Font = Enum.Font.Gotham; label.TextSize = 14; label.TextXAlignment = Enum.TextXAlignment.Left

			local valLabel = Instance.new("TextLabel", holder)
			valLabel.Size = UDim2.new(0,60,0,18); valLabel.AnchorPoint = Vector2.new(1,0); valLabel.Position = UDim2.new(1,0,0,0)
			valLabel.BackgroundTransparency = 1; valLabel.Text = tostring(default); valLabel.TextColor3 = Color3.fromRGB(200,200,200); valLabel.Font = Enum.Font.Gotham; valLabel.TextSize = 13

			local track = Instance.new("Frame", holder)
			track.Position = UDim2.fromOffset(0, 26); track.Size = UDim2.new(1, 0, 0, 10); track.BackgroundColor3 = Color3.fromRGB(28,28,34); track.BorderSizePixel = 0
			Instance.new("UICorner", track).CornerRadius = UDim.new(0,6)

			local fill = Instance.new("Frame", track)
			fill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0); fill.Position = UDim2.new(0,0,0,0)
			fill.BackgroundColor3 = Color3.fromRGB(0,160,255); fill.BorderSizePixel = 0
			Instance.new("UICorner", fill).CornerRadius = UDim.new(0,6)
			local fillStroke = Instance.new("UIStroke", fill); fillStroke.Color = Color3.fromRGB(80,220,255); fillStroke.Transparency = 0.2

			local dragging = false
			local function setFromPosition(x)
				local absPos = x - track.AbsolutePosition.X
				local ratio = clamp(absPos / track.AbsoluteSize.X, 0, 1)
				local value = min + (max - min) * ratio
				fill.Size = UDim2.new(ratio, 0, 1, 0)
				valLabel.Text = tostring(math.floor(value + 0.5))
				if typeof(callback) == "function" then pcall(callback, value) end
			end

			track.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					dragging = true
					setFromPosition(input.Position.X)
				end
			end)
			track.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then dragging = false end
			end)
			UIS.InputChanged:Connect(function(input)
				if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then setFromPosition(input.Position.X) end
			end)
			track.MouseEnter:Connect(function() tween(fillStroke, {Transparency = 0}, TweenInfo.new(0.12)) end)
			track.MouseLeave:Connect(function() tween(fillStroke, {Transparency = 0.2}, TweenInfo.new(0.18)) end)

			return {
				Frame = holder,
				SetValue = function(v) v = clamp(tonumber(v) or min, min, max); local ratio = (v - min) / (max - min); fill.Size = UDim2.new(ratio,0,1,0); valLabel.Text = tostring(math.floor(v+0.5)); if typeof(callback) == "function" then pcall(callback, v) end end,
				GetValue = function() return tonumber(valLabel.Text) end
			}
		end

		function tabObj:CreateDropdown(txt, options, defaultIndex, callback)
			txt = tostring_safe(txt or "Dropdown")
			options = (typeof(options) == "table") and options or {}
			defaultIndex = tonumber(defaultIndex) or 1
			if defaultIndex < 1 then defaultIndex = 1 end
			if defaultIndex > #options then defaultIndex = #options end

			local holder = Instance.new("Frame")
			holder.Size = UDim2.new(1, -24, 0, 44); holder.BackgroundTransparency = 1; holder.Parent = Content

			local label = Instance.new("TextLabel", holder)
			label.Size = UDim2.new(0.5, 0, 1, 0); label.BackgroundTransparency = 1; label.Text = txt
			label.TextColor3 = Color3.fromRGB(230,230,230); label.Font = Enum.Font.Gotham; label.TextSize = 14; label.TextXAlignment = Enum.TextXAlignment.Left

			local btn = Instance.new("TextButton", holder)
			btn.AnchorPoint = Vector2.new(1,0.5); btn.Position = UDim2.new(1, -12, 0.5, 0); btn.Size = UDim2.new(0,150,0,36)
			btn.BackgroundColor3 = Color3.fromRGB(22,22,28); btn.BorderSizePixel = 0
			btn.Text = tostring_safe(options[defaultIndex] or "Select"); btn.Font = Enum.Font.Gotham; btn.TextSize = 14; btn.TextColor3 = Color3.fromRGB(220,220,220)
			Instance.new("UICorner", btn).CornerRadius = UDim.new(0,8)
			local stroke = ApplyNeon(btn); stroke.Transparency = 0.8

			-- Dropdown frame (child of PagesHolder to overlay content correctly)
			local dropdown = Instance.new("Frame", PagesHolder)
			dropdown.Name = "Dropdown_" .. tostring(idx)
			dropdown.Size = UDim2.new(0, 150, 0, 0)
			dropdown.BackgroundColor3 = Color3.fromRGB(18,18,22)
			dropdown.BorderSizePixel = 0
			dropdown.Visible = false
			Instance.new("UICorner", dropdown).CornerRadius = UDim.new(0,8)

			local list = Instance.new("ScrollingFrame", dropdown)
			list.Size = UDim2.new(1,0,1,0); list.BackgroundTransparency = 1; list.ScrollBarThickness = 6
			local llayout = Instance.new("UIListLayout", list); llayout.Padding = UDim.new(0,4); llayout.SortOrder = Enum.SortOrder.LayoutOrder

			local function rebuild()
				for _, c in ipairs(list:GetChildren()) do if c:IsA("TextButton") then c:Destroy() end end
				for i,v in ipairs(options) do
					local opt = Instance.new("TextButton")
					opt.Size = UDim2.new(1, -8, 0, 32); opt.Position = UDim2.fromOffset(4, 4 + (i-1)*36)
					opt.BackgroundColor3 = Color3.fromRGB(22,22,26); opt.BorderSizePixel = 0; opt.Text = tostring_safe(v)
					opt.TextColor3 = Color3.fromRGB(220,220,220); opt.Font = Enum.Font.Gotham; opt.TextSize = 14
					opt.Parent = list; Instance.new("UICorner", opt).CornerRadius = UDim.new(0,6)
					local optStroke = ApplyNeon(opt); optStroke.Transparency = 0.9
					opt.MouseEnter:Connect(function() tween(optStroke, {Transparency = 0.3}) end)
					opt.MouseLeave:Connect(function() tween(optStroke, {Transparency = 0.9}) end)
					opt.MouseButton1Click:Connect(function()
						btn.Text = opt.Text
						dropdown.Visible = false
						tween(stroke, {Transparency = 0.8})
						if typeof(callback) == "function" then pcall(callback, v, i) end
					end)
				end
				list.CanvasSize = UDim2.new(0,0,0, llayout.AbsoluteContentSize.Y + 8)
				dropdown.Size = UDim2.new(0, 150, 0, math.min(6, #options) * 36 + 8)
			end
			rebuild()

			btn.MouseButton1Click:Connect(function()
				dropdown.Position = PagesHolder:FindFirstChildWhichIsA("Frame") and UDim2.new(0, 0, 0, 0) or UDim2.new(0,0,0,0)
				dropdown.Position = btn.AbsolutePosition and UDim2.new(0, btn.AbsolutePosition.X - PagesHolder.AbsolutePosition.X, 0, btn.AbsolutePosition.Y - PagesHolder.AbsolutePosition.Y + btn.AbsoluteSize.Y) or dropdown.Position
				dropdown.Visible = not dropdown.Visible
				if dropdown.Visible then tween(stroke, {Transparency = 0}, TweenInfo.new(0.18)) else tween(stroke, {Transparency = 0.8}, TweenInfo.new(0.18)) end
			end)

			return { Frame = holder, SetOptions = function(newOptions, newDefault) options = newOptions or {}; defaultIndex = newDefault or defaultIndex; rebuild() end, GetValue = function() return btn.Text end }
		end

		function tabObj:CreateTextbox(labelText, placeholder, callback)
			labelText = tostring_safe(labelText or "Text")
			placeholder = tostring_safe(placeholder or "")
			local holder = Instance.new("Frame")
			holder.Size = UDim2.new(1, -24, 0, 44); holder.BackgroundTransparency = 1; holder.Parent = Content

			local label = Instance.new("TextLabel", holder)
			label.Size = UDim2.new(0.5, 0, 1, 0); label.BackgroundTransparency = 1; label.Text = labelText
			label.TextColor3 = Color3.fromRGB(230,230,230); label.Font = Enum.Font.Gotham; label.TextSize = 14; label.TextXAlignment = Enum.TextXAlignment.Left

			local box = Instance.new("TextBox", holder)
			box.AnchorPoint = Vector2.new(1,0.5); box.Position = UDim2.new(1, -12, 0.5, 0); box.Size = UDim2.new(0,220,0,32)
			box.BackgroundColor3 = Color3.fromRGB(22,22,28); box.BorderSizePixel = 0; box.ClearTextOnFocus = false
			box.Text = ""; box.PlaceholderText = placeholder; box.Font = Enum.Font.Gotham; box.TextSize = 14; box.TextColor3 = Color3.fromRGB(220,220,220)
			Instance.new("UICorner", box).CornerRadius = UDim.new(0,6)
			local stroke = ApplyNeon(box); stroke.Transparency = 0.9

			box.Focused:Connect(function() tween(stroke, {Transparency = 0}, TweenInfo.new(0.14)); tween(box, {Size = box.Size * UDim2.fromScale(1.002,1.002)}, TweenInfo.new(0.12)) end)
			box.FocusLost:Connect(function(enter) tween(stroke, {Transparency = 0.9}, TweenInfo.new(0.18)); tween(box, {Size = box.Size}, TweenInfo.new(0.12)); if enter and typeof(callback) == "function" then pcall(callback, box.Text) end end)

			return { Frame = holder, GetText = function() return box.Text end, SetText = function(v) box.Text = tostring_safe(v) end }
		end

		return tabObj
	end

	-- Public API (executor-friendly)
	local API = {}
	API.Window = Window
	API.CreateTab = function(_, a, b) return Window:CreateTab(a,b) end
	API.Destroy = function() if ScreenGui and ScreenGui.Parent then ScreenGui:Destroy() end end

	-- Run optional callback
	if typeof(Callback) == "function" then pcall(Callback) end

	return API
end

return KazeUI
