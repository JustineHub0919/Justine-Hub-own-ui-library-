-- KazeUI (Full) - Responsive, Neon, Multi-Tab UI Library
-- Features:
-- - Fixed tab column (not a ScrollingFrame)
-- - Each tab has its own scrolling content area
-- - Tabs return an object with .Content and element creation helpers
-- - Glowing neon UI using UIStroke and tweens
-- - Mobile + PC safe
-- - Executor-friendly (single Script/Module use)

local KazeUI = {}
KazeUI.__index = KazeUI

-- Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer

-- Helpers
local function clamp(v, a, b) if v < a then return a elseif v > b then return b end return v end
local function tostring_safe(v) if typeof(v) == "table" then return tostring(v) end return tostring(v) end

-- Tween helper
local function tween(instance, props, info)
	info = info or TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local t = TweenService:Create(instance, info, props)
	t:Play()
	return t
end

-- Create base ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "KazeUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = LP:WaitForChild("PlayerGui")

-- UIScale for responsiveness
local UIScale = Instance.new("UIScale")
UIScale.Parent = ScreenGui
local function UpdateScale()
	local size = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280,720)
	if size.X < 600 then
		UIScale.Scale = math.clamp(size.X / 800, 0.48, 0.9)
	else
		UIScale.Scale = math.clamp(size.X / 1920, 0.6, 1)
	end
end
UpdateScale()
if workspace.CurrentCamera then
	workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(UpdateScale)
end

-- Format image id safely
local function FormatImage(id)
	if not id then return "" end
	id = tostring_safe(id)
	local digits = string.gsub(id, "%D", "")
	if digits == "" then return "" end
	return "rbxassetid://" .. digits
end

-- Drag helper
local function MakeDraggable(dragPart, targetPart)
	local dragging, dragInput, dragStart, startPos = false, nil, nil, nil
	local function update(input)
		if not dragStart or not startPos then return end
		local delta = input.Position - dragStart
		targetPart.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end
	dragPart.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = targetPart.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					dragInput = nil
				end
			end)
		end
	end)
	dragPart.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	UIS.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
end

-- Main API
function KazeUI:CreateWindow(config)
	config = config or {}
	local Title = tostring_safe(config.Title or "Kaze UI")
	local Author = tostring_safe(config.Author or "Unknown")
	local Version = tostring_safe(config.Version or "1.0")
	local MainIcon = FormatImage(config.Icon or "6031763447")
	local OpenIcon = FormatImage((config.OpenButton and config.OpenButton.Icon) or config.Icon or "6031763447")
	local MiniButtonSize = UDim2.fromOffset(60, 60)
	local Callback = config.Callback

	-- Window container
	local Window = Instance.new("Frame")
	Window.Name = "KazeUI_MainWindow"
	Window.AnchorPoint = Vector2.new(0.5, 0.5)
	Window.Position = UDim2.fromScale(0.5, 0.5)
	Window.Size = UDim2.fromOffset(700, 480)
	Window.BackgroundColor3 = Color3.fromRGB(18,18,22)
	Window.BorderSizePixel = 0
	Window.Parent = ScreenGui
	Window.ClipsDescendants = true
	local wc = Instance.new("UICorner", Window); wc.CornerRadius = UDim.new(0, 14)
	local wStroke = Instance.new("UIStroke", Window); wStroke.Color = Color3.fromRGB(0,160,255); wStroke.Thickness = 2; wStroke.Transparency = 0.6

	-- Neon pulse for stroke
	spawn(function()
		local info = TweenInfo.new(1.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
		local t = TweenService:Create(wStroke, info, {Transparency = 0})
		t:Play()
	end)

	-- Responsive size adjustments
	local function AdjustWindowSize()
		local size = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280,720)
		if size.X <= 600 then
			Window.Size = UDim2.new(0.94, 0, 0.88, 0)
		elseif size.X <= 1280 then
			Window.Size = UDim2.new(0.78, 0, 0.76, 0)
		else
			Window.Size = UDim2.new(0.60, 0, 0.72, 0)
		end
		Window.Position = UDim2.fromScale(0.5, 0.5)
	end
	AdjustWindowSize()
	if workspace.CurrentCamera then
		workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(AdjustWindowSize)
	end

	-- TopBar
	local TopBar = Instance.new("Frame")
	TopBar.Name = "TopBar"
	TopBar.Size = UDim2.new(1, 0, 0, 56)
	TopBar.Position = UDim2.new(0,0,0,0)
	TopBar.BackgroundColor3 = Color3.fromRGB(15,15,18)
	TopBar.BorderSizePixel = 0
	TopBar.Parent = Window
	local tbCorner = Instance.new("UICorner", TopBar); tbCorner.CornerRadius = UDim.new(0, 14)

	local Icon = Instance.new("ImageLabel")
	Icon.Size = UDim2.fromOffset(34,34)
	Icon.Position = UDim2.fromOffset(12,11)
	Icon.BackgroundTransparency = 1
	Icon.Image = MainIcon
	Icon.Parent = TopBar
	local iconCorner = Instance.new("UICorner", Icon); iconCorner.CornerRadius = UDim.new(1,0)

	local TitleLabel = Instance.new("TextLabel")
	TitleLabel.Size = UDim2.new(1, -220, 0, 22)
	TitleLabel.Position = UDim2.fromOffset(58,8)
	TitleLabel.BackgroundTransparency = 1
	TitleLabel.Text = Title
	TitleLabel.TextColor3 = Color3.fromRGB(235,235,235)
	TitleLabel.Font = Enum.Font.GothamBold
	TitleLabel.TextSize = 16
	TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
	TitleLabel.Parent = TopBar

	local SubLabel = Instance.new("TextLabel")
	SubLabel.Size = UDim2.new(1, -220, 0, 18)
	SubLabel.Position = UDim2.fromOffset(58,30)
	SubLabel.BackgroundTransparency = 1
	SubLabel.Text = Author .. " | v" .. Version
	SubLabel.TextColor3 = Color3.fromRGB(160,160,160)
	SubLabel.Font = Enum.Font.Gotham
	SubLabel.TextSize = 13
	SubLabel.TextXAlignment = Enum.TextXAlignment.Left
	SubLabel.Parent = TopBar

	-- Minimize & Close
	local Minimize = Instance.new("TextButton")
	Minimize.Size = UDim2.fromOffset(36,36)
	Minimize.Position = UDim2.new(1, -88, 0.5, -18)
	Minimize.Text = "—"
	Minimize.Font = Enum.Font.GothamBold
	Minimize.TextSize = 20
	Minimize.TextColor3 = Color3.fromRGB(220,220,220)
	Minimize.BackgroundColor3 = Color3.fromRGB(22,22,26)
	Minimize.Parent = TopBar
	local minCorner = Instance.new("UICorner", Minimize); minCorner.CornerRadius = UDim.new(1,0)
	local Close = Instance.new("TextButton")
	Close.Size = UDim2.fromOffset(36,36)
	Close.Position = UDim2.new(1, -44, 0.5, -18)
	Close.Text = "✕"
	Close.Font = Enum.Font.GothamBold
	Close.TextSize = 18
	Close.TextColor3 = Color3.fromRGB(255,90,90)
	Close.BackgroundColor3 = Color3.fromRGB(22,22,26)
	Close.Parent = TopBar
	local closeCorner = Instance.new("UICorner", Close); closeCorner.CornerRadius = UDim.new(1,0)

	-- Make draggable
	MakeDraggable(TopBar, Window)

	-- Main layout: left fixed tabs column, right content area
	local MainArea = Instance.new("Frame")
	MainArea.Name = "MainArea"
	MainArea.Position = UDim2.new(0,0,0,56)
	MainArea.Size = UDim2.new(1,0,1,-56)
	MainArea.BackgroundTransparency = 1
	MainArea.Parent = Window

	-- Tabs Column (fixed frame, not a ScrollingFrame)
	local TabsColumn = Instance.new("Frame")
	TabsColumn.Name = "TabsColumn"
	TabsColumn.Size = UDim2.new(0, 220, 1, -24)
	TabsColumn.Position = UDim2.fromOffset(12,12)
	TabsColumn.BackgroundColor3 = Color3.fromRGB(18,18,22)
	TabsColumn.BorderSizePixel = 0
	TabsColumn.Parent = MainArea
	local tcCorner = Instance.new("UICorner", TabsColumn); tcCorner.CornerRadius = UDim.new(0,12)

	-- Tabs header (optional)
	local TabsHeader = Instance.new("TextLabel")
	TabsHeader.Size = UDim2.new(1, -24, 0, 28)
	TabsHeader.Position = UDim2.fromOffset(12,8)
	TabsHeader.BackgroundTransparency = 1
	TabsHeader.Text = "Tabs"
	TabsHeader.Font = Enum.Font.GothamBold
	TabsHeader.TextSize = 14
	TabsHeader.TextColor3 = Color3.fromRGB(200,200,200)
	TabsHeader.TextXAlignment = Enum.TextXAlignment.Left
	TabsHeader.Parent = TabsColumn

	-- Buttons holder inside TabsColumn (fixed)
	local TabsHolder = Instance.new("Frame")
	TabsHolder.Name = "TabsHolder"
	TabsHolder.Position = UDim2.fromOffset(12, 40)
	TabsHolder.Size = UDim2.new(1, -24, 1, -52)
	TabsHolder.BackgroundTransparency = 1
	TabsHolder.ClipsDescendants = true
	TabsHolder.Parent = TabsColumn

	local TabsLayout = Instance.new("UIListLayout", TabsHolder)
	TabsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	TabsLayout.Padding = UDim.new(0,8)

	-- Pages container (right side)
	local PagesHolder = Instance.new("Frame")
	PagesHolder.Name = "PagesHolder"
	PagesHolder.Size = UDim2.new(1, -244, 1, -24)
	PagesHolder.Position = UDim2.fromOffset(232, 12)
	PagesHolder.BackgroundTransparency = 1
	PagesHolder.Parent = MainArea

	-- Data holders
	local tabs = {}
	local activeTab = nil

	-- MiniButton (minimize)
	local MiniButton = Instance.new("ImageButton")
	MiniButton.Name = "KazeUI_MiniButton"
	MiniButton.Size = MiniButtonSize
	MiniButton.Position = UDim2.fromScale(0.1, 0.1)
	MiniButton.BackgroundColor3 = Color3.fromRGB(20,20,25)
	MiniButton.BorderSizePixel = 0
	MiniButton.Visible = false
	MiniButton.Parent = ScreenGui
	MiniButton.ZIndex = 999
	MiniButton.ScaleType = Enum.ScaleType.Slice
	MiniButton.SliceCenter = Rect.new(6,6,54,54)
	local miniCorner = Instance.new("UICorner", MiniButton); miniCorner.CornerRadius = UDim.new(0,12)
	local miniPad = Instance.new("UIPadding", MiniButton)
	miniPad.PaddingTop = UDim.new(0,6); miniPad.PaddingBottom = UDim.new(0,6); miniPad.PaddingLeft = UDim.new(0,6); miniPad.PaddingRight = UDim.new(0,6)
	local MiniIcon = Instance.new("ImageLabel", MiniButton)
	MiniIcon.Size = UDim2.fromScale(1,1); MiniIcon.BackgroundTransparency = 1; MiniIcon.AnchorPoint = Vector2.new(0.5,0.5); MiniIcon.Position = UDim2.fromScale(0.5,0.5); MiniIcon.Image = OpenIcon

	-- Neon stroke for MiniButton
	local MiniStroke = Instance.new("UIStroke", MiniButton); MiniStroke.Color = Color3.fromRGB(0,160,255); MiniStroke.Thickness = 2.2; MiniStroke.Transparency = 0.6
	spawn(function() TweenService:Create(MiniStroke, TweenInfo.new(1.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Transparency = 0}):Play() end)
	MakeDraggable(MiniButton, MiniButton)

	Minimize.MouseButton1Click:Connect(function()
		Window.Visible = false
		MiniButton.Visible = true
		MiniButton.Size = UDim2.fromOffset(0,0)
		tween(MiniButton, {Size = MiniButtonSize}, TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out))
	end)
	MiniButton.MouseButton1Click:Connect(function()
		MiniButton.Visible = false
		Window.Visible = true
		local final = Window.Size
		Window.Size = UDim2.fromOffset(0,0)
		tween(Window, {Size = final}, TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out))
	end)

	-- Close confirmation
	local function ShowCloseConfirm()
		Minimize.Active = false
		Close.Active = false
		local Overlay = Instance.new("Frame", Window)
		Overlay.Size = UDim2.new(1,0,1,0); Overlay.Position = UDim2.new(0,0); Overlay.BackgroundColor3 = Color3.fromRGB(0,0,0); Overlay.BackgroundTransparency = 0.6; Overlay.ZIndex = 50
		local ConfirmWindow = Instance.new("Frame", Overlay); ConfirmWindow.Size = UDim2.fromOffset(360,160); ConfirmWindow.AnchorPoint = Vector2.new(0.5,0.5); ConfirmWindow.Position = UDim2.fromScale(0.5,0.5); ConfirmWindow.BackgroundColor3 = Color3.fromRGB(22,22,26)
		Instance.new("UICorner", ConfirmWindow).CornerRadius = UDim.new(0,12)
		local txt = Instance.new("TextLabel", ConfirmWindow); txt.Size = UDim2.new(1,-32,0,64); txt.Position = UDim2.fromOffset(16,12); txt.BackgroundTransparency = 1; txt.Text = "Close the UI?"; txt.Font = Enum.Font.GothamBold; txt.TextSize = 18; txt.TextColor3 = Color3.fromRGB(230,230,230)
		local buttons = Instance.new("Frame", ConfirmWindow); buttons.Size = UDim2.new(1,0,0,44); buttons.AnchorPoint = Vector2.new(0,1); buttons.Position = UDim2.new(0,0,1,0); buttons.BackgroundTransparency = 1
		local layout = Instance.new("UIListLayout", buttons); layout.FillDirection = Enum.FillDirection.Horizontal; layout.HorizontalAlignment = Enum.HorizontalAlignment.Center; layout.Padding = UDim.new(0,12)
		local confirm = Instance.new("TextButton", buttons); confirm.Size = UDim2.new(0,140,0,36); confirm.BackgroundColor3 = Color3.fromRGB(0,170,255); confirm.Text = "Confirm"; confirm.Font = Enum.Font.GothamBold; confirm.TextSize = 16; Instance.new("UICorner", confirm).CornerRadius = UDim.new(0,8)
		local cancel = Instance.new("TextButton", buttons); cancel.Size = UDim2.new(0,140,0,36); cancel.BackgroundColor3 = Color3.fromRGB(40,40,46); cancel.Text = "Cancel"; cancel.Font = Enum.Font.GothamBold; cancel.TextSize = 16; Instance.new("UICorner", cancel).CornerRadius = UDim.new(0,8)
		confirm.MouseButton1Click:Connect(function() ScreenGui:Destroy() end)
		cancel.MouseButton1Click:Connect(function() Overlay:Destroy(); Minimize.Active = true; Close.Active = true end)
	end
	Close.MouseButton1Click:Connect(ShowCloseConfirm)

	-- Helper to create neon stroke and animated hover behavior
	local function ApplyNeon(instance, strokeColor)
		strokeColor = strokeColor or Color3.fromRGB(0,160,255)
		local stroke = Instance.new("UIStroke")
		stroke.Parent = instance
		stroke.Color = strokeColor
		stroke.Thickness = 2
		stroke.Transparency = 0.7
		stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		-- Slight hover scale using AnchorPoint center
		return stroke
	end

	-- Tab activation function
	local function SetActive(tabObj)
		for _, t in ipairs(tabs) do
			if t.Button then
				t.Button.BackgroundColor3 = Color3.fromRGB(28,28,34)
				if t.Stroke then tween(t.Stroke, {Transparency = 0.7}) end
				t.Button.TextColor3 = Color3.fromRGB(220,220,220)
			end
			if t.Content then t.Content.Visible = false end
		end
		if tabObj and tabObj.Button then
			tabObj.Button.BackgroundColor3 = Color3.fromRGB(0,160,255)
			if tabObj.Stroke then tween(tabObj.Stroke, {Transparency = 0}) end
			tabObj.Button.TextColor3 = Color3.fromRGB(18,18,20)
		end
		if tabObj and tabObj.Content then
			tabObj.Content.Visible = true
		end
		activeTab = tabObj
	end

	-- CreateTab implementation: returns table with .Content and creation helpers
	function Window:CreateTab(tabArg, iconArg)
		-- Normalize inputs (string or table)
		local title, icon = nil, nil
		if typeof(tabArg) == "table" then
			title = tabArg.Name or tabArg.Title or tabArg.Text or tabArg.name or tabArg.title or tabArg.text
			icon = tabArg.Icon or tabArg.Image or tabArg.icon or tabArg.image or iconArg
		else
			title = tabArg
			icon = iconArg
		end
		if not title or title == "" then
			title = "Tab " .. tostring(#tabs + 1)
		end
		title = tostring_safe(title)
		local iconImage = FormatImage(icon or "")

		local idx = #tabs + 1

		-- Create button (in TabsHolder - fixed)
		local Btn = Instance.new("TextButton")
		Btn.Name = "Kaze_TabButton_" .. tostring(idx)
		Btn.Size = UDim2.new(1, -12, 0, 52)
		Btn.BackgroundColor3 = Color3.fromRGB(28,28,34)
		Btn.BorderSizePixel = 0
		Btn.Text = title
		Btn.TextColor3 = Color3.fromRGB(220,220,220)
		Btn.Font = Enum.Font.GothamBold
		Btn.TextSize = 16
		Btn.Parent = TabsHolder
		Instance.new("UICorner", Btn).CornerRadius = UDim.new(0,10)
		Btn.LayoutOrder = idx

		-- left icon
		local BtnIcon = Instance.new("ImageLabel")
		BtnIcon.Parent = Btn
		BtnIcon.BackgroundTransparency = 1
		BtnIcon.Size = UDim2.fromOffset(36,36)
		BtnIcon.Position = UDim2.fromOffset(8,8)
		BtnIcon.Image = iconImage
		Instance.new("UICorner", BtnIcon).CornerRadius = UDim.new(1,0)

		-- padding so text does not overlap
		local pad = Instance.new("UIPadding", Btn)
		pad.PaddingLeft = UDim.new(0,56)

		-- add neon stroke (for active glow)
		local stroke = ApplyNeon(Btn)
		stroke.Transparency = 0.7

		-- Hover + press effects for tab button
		Btn.MouseEnter:Connect(function()
			tween(Btn, {Size = UDim2.new(Btn.Size.X.Scale, Btn.Size.X.Offset, Btn.Size.Y.Scale, Btn.Size.Y.Offset)}, TweenInfo.new(0.12))
			tween(stroke, {Transparency = 0.35}, TweenInfo.new(0.18))
		end)
		Btn.MouseLeave:Connect(function()
			if activeTab and activeTab.Button == Btn then
				tween(stroke, {Transparency = 0}, TweenInfo.new(0.18))
			else
				tween(stroke, {Transparency = 0.7}, TweenInfo.new(0.18))
			end
		end)
		Btn.MouseButton1Down:Connect(function()
			tween(Btn, {Size = Btn.Size * UDim2.fromScale(0.995, 0.995)}, TweenInfo.new(0.06))
		end)
		Btn.MouseButton1Up:Connect(function()
			tween(Btn, {Size = Btn.Size * UDim2.fromScale(1.005, 1.005)}, TweenInfo.new(0.08))
			tween(Btn, {Size = Btn.Size}, TweenInfo.new(0.08))
		end)

		-- Create content area (a ScrollingFrame so only content scrolls)
		local Content = Instance.new("ScrollingFrame")
		Content.Name = "TabContent_" .. tostring(idx)
		Content.Size = UDim2.new(1, 0, 1, 0)
		Content.Position = UDim2.new(0, 0, 0, 0)
		Content.BackgroundTransparency = 1
		Content.ScrollBarThickness = 8
		Content.CanvasSize = UDim2.new(0, 0, 0, 0)
		Content.AutomaticCanvasSize = Enum.AutomaticSize.Y
		Content.Visible = false
		Content.Parent = PagesHolder

		local contentPadding = Instance.new("UIPadding", Content)
		contentPadding.PaddingTop = UDim.new(0,12); contentPadding.PaddingLeft = UDim.new(0,12); contentPadding.PaddingRight = UDim.new(0,12)

		local contentLayout = Instance.new("UIListLayout", Content)
		contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
		contentLayout.Padding = UDim.new(0,12)
		contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center

		-- Keep canvas updated
		contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
			Content.CanvasSize = UDim2.new(0,0,0, contentLayout.AbsoluteContentSize.Y + 16)
		end)

		-- Add to tabs table
		local tabObj = { Button = Btn, Content = Content, Stroke = stroke }
		table.insert(tabs, tabObj)

		-- Button click sets active
		Btn.MouseButton1Click:Connect(function()
			SetActive(tabObj)
		end)

		-- Select first tab by default
		if #tabs == 1 then
			SetActive(tabObj)
		end

		-- Element creation helpers on the tab object

		-- CreateButton(text, callback)
		function tabObj:CreateButton(txt, callback)
			txt = tostring_safe(txt or "Button")
			local btn = Instance.new("TextButton")
			btn.Size = UDim2.new(1, -24, 0, 44)
			btn.BackgroundColor3 = Color3.fromRGB(20,20,26)
			btn.BorderSizePixel = 0
			btn.Text = txt
			btn.TextColor3 = Color3.fromRGB(235,235,235)
			btn.Font = Enum.Font.GothamBold
			btn.TextSize = 16
			btn.Parent = Content
			Instance.new("UICorner", btn).CornerRadius = UDim.new(0,8)

			-- Neon stroke outline
			local s = ApplyNeon(btn)
			s.Transparency = 0.8

			-- Hover and press animations
			btn.MouseEnter:Connect(function()
				tween(s, {Transparency = 0.2}, TweenInfo.new(0.14))
				tween(btn, {Size = btn.Size * UDim2.fromScale(1.004, 1.004)}, TweenInfo.new(0.12))
			end)
			btn.MouseLeave:Connect(function()
				tween(s, {Transparency = 0.8}, TweenInfo.new(0.14))
				tween(btn, {Size = btn.Size}, TweenInfo.new(0.12))
			end)
			btn.MouseButton1Down:Connect(function()
				tween(btn, {Size = btn.Size * UDim2.fromScale(0.994, 0.994)}, TweenInfo.new(0.06))
			end)
			btn.MouseButton1Up:Connect(function()
				tween(btn, {Size = btn.Size}, TweenInfo.new(0.06))
			end)

			if typeof(callback) == "function" then
				btn.MouseButton1Click:Connect(function() pcall(callback) end)
			end
			return btn
		end

		-- CreateToggle(text, default, callback) returns table with Set and Get
		function tabObj:CreateToggle(txt, default, callback)
			txt = tostring_safe(txt or "Toggle")
			default = not not default
			local holder = Instance.new("Frame")
			holder.Size = UDim2.new(1, -24, 0, 44)
			holder.BackgroundTransparency = 1
			holder.Parent = Content

			local label = Instance.new("TextLabel", holder)
			label.Size = UDim2.new(1, -64, 1, 0)
			label.Position = UDim2.fromOffset(0,0)
			label.BackgroundTransparency = 1
			label.Text = txt
			label.TextColor3 = Color3.fromRGB(230,230,230)
			label.Font = Enum.Font.Gotham
			label.TextSize = 15
			label.TextXAlignment = Enum.TextXAlignment.Left

			local toggle = Instance.new("Frame", holder)
			toggle.Size = UDim2.new(0,44,0,26)
			toggle.AnchorPoint = Vector2.new(1,0.5)
			toggle.Position = UDim2.new(1, -12, 0.5, 0)
			toggle.BackgroundColor3 = Color3.fromRGB(26,26,30)
			toggle.BorderSizePixel = 0
			toggle.ClipsDescendants = true
			Instance.new("UICorner", toggle).CornerRadius = UDim.new(0,14)

			local knob = Instance.new("Frame", toggle)
			knob.Size = UDim2.new(0,22,0,22)
			knob.Position = UDim2.fromOffset(2,2)
			knob.BackgroundColor3 = Color3.fromRGB(230,230,230)
			knob.BorderSizePixel = 0
			Instance.new("UICorner", knob).CornerRadius = UDim.new(1,0)

			local stroke = ApplyNeon(toggle); stroke.Transparency = default and 0 or 0.8
			local enabled = default

			local function Set(v)
				enabled = not not v
				if enabled then
					tween(knob, {Position = UDim2.new(1, -24, 0, 2)}, TweenInfo.new(0.16))
					tween(toggle, {BackgroundColor3 = Color3.fromRGB(0,160,255)}, TweenInfo.new(0.16))
					tween(stroke, {Transparency = 0}, TweenInfo.new(0.18))
				else
					tween(knob, {Position = UDim2.fromOffset(2,2)}, TweenInfo.new(0.16))
					tween(toggle, {BackgroundColor3 = Color3.fromRGB(26,26,30)}, TweenInfo.new(0.16))
					tween(stroke, {Transparency = 0.8}, TweenInfo.new(0.18))
				end
				if typeof(callback) == "function" then pcall(callback, enabled) end
			end

			-- Input
			local function ToggleInput()
				Set(not enabled)
			end
			toggle.MouseButton1Click = nil -- ensure not a button
			toggle.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					ToggleInput()
				end
			end)
			-- Initialize
			Set(enabled)

			return {
				Frame = holder,
				Set = Set,
				Get = function() return enabled end
			}
		end

		-- CreateSlider(text, min, max, default, callback)
		function tabObj:CreateSlider(txt, min, max, default, callback)
			txt = tostring_safe(txt or "Slider")
			min = tonumber(min) or 0
			max = tonumber(max) or 100
			if max <= min then max = min + 1 end
			default = tonumber(default) or min
			default = clamp(default, min, max)

			local holder = Instance.new("Frame")
			holder.Size = UDim2.new(1, -24, 0, 64)
			holder.BackgroundTransparency = 1
			holder.Parent = Content

			local label = Instance.new("TextLabel", holder)
			label.Size = UDim2.new(1, -16, 0, 18)
			label.Position = UDim2.fromOffset(0,0)
			label.BackgroundTransparency = 1
			label.Text = txt
			label.TextColor3 = Color3.fromRGB(230,230,230)
			label.Font = Enum.Font.Gotham
			label.TextSize = 14
			label.TextXAlignment = Enum.TextXAlignment.Left

			local valLabel = Instance.new("TextLabel", holder)
			valLabel.Size = UDim2.new(0,60,0,18)
			valLabel.AnchorPoint = Vector2.new(1,0)
			valLabel.Position = UDim2.new(1, 0, 0, 0)
			valLabel.BackgroundTransparency = 1
			valLabel.Text = tostring(default)
			valLabel.TextColor3 = Color3.fromRGB(200,200,200)
			valLabel.Font = Enum.Font.Gotham
			valLabel.TextSize = 13

			local track = Instance.new("Frame", holder)
			track.Position = UDim2.fromOffset(0, 26)
			track.Size = UDim2.new(1, 0, 0, 10)
			track.BackgroundColor3 = Color3.fromRGB(28,28,34)
			track.BorderSizePixel = 0
			Instance.new("UICorner", track).CornerRadius = UDim.new(0,6)

			local fill = Instance.new("Frame", track)
			fill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
			fill.Position = UDim2.new(0,0,0,0)
			fill.BackgroundColor3 = Color3.fromRGB(0,160,255)
			fill.BorderSizePixel = 0
			local fillCorner = Instance.new("UICorner", fill); fillCorner.CornerRadius = UDim.new(0,6)
			local fillStroke = Instance.new("UIStroke", fill); fillStroke.Color = Color3.fromRGB(80,220,255); fillStroke.Transparency = 0.2

			local dragging = false
			local function setFromPosition(x)
				local absPos = x - track.AbsolutePosition.X
				local ratio = clamp(absPos / track.AbsoluteSize.X, 0, 1)
				local value = min + (max - min) * ratio
				fill.Size = UDim2.new(ratio, 0, 1, 0)
				valLabel.Text = tostring(math.floor(value + 0.5))
				if typeof(callback) == "function" then pcall(callback, value) end
			end

			track.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					dragging = true
					setFromPosition(input.Position.X)
				end
			end)
			track.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					dragging = false
				end
			end)
			UIS.InputChanged:Connect(function(input)
				if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
					setFromPosition(input.Position.X)
				end
			end)

			-- Glow on hover
			track.MouseEnter:Connect(function() tween(fillStroke, {Transparency = 0}, TweenInfo.new(0.12)) end)
			track.MouseLeave:Connect(function() tween(fillStroke, {Transparency = 0.2}, TweenInfo.new(0.18)) end)

			return {
				Frame = holder,
				SetValue = function(v)
					v = clamp(tonumber(v) or min, min, max)
					local ratio = (v - min) / (max - min)
					fill.Size = UDim2.new(ratio, 0, 1, 0)
					valLabel.Text = tostring(math.floor(v + 0.5))
					if typeof(callback) == "function" then pcall(callback, v) end
				end,
				GetValue = function()
					return tonumber(valLabel.Text or tostring(default))
				end
			}
		end

		-- CreateDropdown(text, optionsTable, defaultIndex, callback)
		function tabObj:CreateDropdown(txt, options, defaultIndex, callback)
			txt = tostring_safe(txt or "Dropdown")
			options = (typeof(options) == "table") and options or {}
			defaultIndex = tonumber(defaultIndex) or 1
			if defaultIndex < 1 then defaultIndex = 1 end
			if defaultIndex > #options then defaultIndex = #options end

			local holder = Instance.new("Frame")
			holder.Size = UDim2.new(1, -24, 0, 44)
			holder.BackgroundTransparency = 1
			holder.Parent = Content

			local label = Instance.new("TextLabel", holder)
			label.Size = UDim2.new(0.5, 0, 1, 0)
			label.BackgroundTransparency = 1
			label.Text = txt
			label.TextColor3 = Color3.fromRGB(230,230,230)
			label.Font = Enum.Font.Gotham
			label.TextSize = 14
			label.TextXAlignment = Enum.TextXAlignment.Left

			local btn = Instance.new("TextButton", holder)
			btn.AnchorPoint = Vector2.new(1,0.5)
			btn.Position = UDim2.new(1, -12, 0.5, 0)
			btn.Size = UDim2.new(0,150,0,36)
			btn.BackgroundColor3 = Color3.fromRGB(22,22,28)
			btn.BorderSizePixel = 0
			btn.Text = tostring(options[defaultIndex] or "Select")
			btn.Font = Enum.Font.Gotham
			btn.TextSize = 14
			btn.TextColor3 = Color3.fromRGB(220,220,220)
			Instance.new("UICorner", btn).CornerRadius = UDim.new(0,8)

			local stroke = ApplyNeon(btn); stroke.Transparency = 0.8

			local dropdown = Instance.new("Frame", window or holder)
			dropdown.Name = "Dropdown_" .. tostring(idx)
			dropdown.Size = UDim2.new(0, 150, 0, 0)
			dropdown.Position = UDim2.new(1, -12, 0, 44)
			dropdown.BackgroundColor3 = Color3.fromRGB(18,18,22)
			dropdown.BorderSizePixel = 0
			dropdown.Visible = false
			if dropdown.Parent ~= PagesHolder then
				dropdown.Parent = Content
			end
			Instance.new("UICorner", dropdown).CornerRadius = UDim.new(0,8)

			local list = Instance.new("ScrollingFrame", dropdown)
			list.Size = UDim2.new(1,0,1,0)
			list.BackgroundTransparency = 1
			list.ScrollBarThickness = 6
			list.CanvasSize = UDim2.new(0,0,0,0)
			list.AutomaticCanvasSize = Enum.AutomaticSize.Y
			local llayout = Instance.new("UIListLayout", list)
			llayout.Padding = UDim.new(0,4)
			llayout.SortOrder = Enum.SortOrder.LayoutOrder
			local function rebuild()
				for i,v in ipairs(options) do
					local opt = Instance.new("TextButton")
					opt.Size = UDim2.new(1, -8, 0, 32)
					opt.Position = UDim2.fromOffset(4, 4 + (i-1)*36)
					opt.BackgroundColor3 = Color3.fromRGB(22,22,26)
					opt.BorderSizePixel = 0
					opt.Text = tostring_safe(v)
					opt.TextColor3 = Color3.fromRGB(220,220,220)
					opt.Font = Enum.Font.Gotham
					opt.TextSize = 14
					opt.Parent = list
					Instance.new("UICorner", opt).CornerRadius = UDim.new(0,6)
					local optStroke = ApplyNeon(opt); optStroke.Transparency = 0.9
					opt.MouseEnter:Connect(function() tween(optStroke, {Transparency = 0.3}) end)
					opt.MouseLeave:Connect(function() tween(optStroke, {Transparency = 0.9}) end)
					opt.MouseButton1Click:Connect(function()
						btn.Text = opt.Text
						dropdown.Visible = false
						stroke.Transparency = 0.8
						if typeof(callback) == "function" then pcall(callback, v, i) end
					end)
				end
				list.CanvasSize = UDim2.new(0,0,0, llayout.AbsoluteContentSize.Y + 8)
				dropdown.Size = UDim2.new(0, 150, 0, math.min(6, #options) * 36 + 8)
			end
			rebuild()

			btn.MouseButton1Click:Connect(function()
				dropdown.Visible = not dropdown.Visible
				if dropdown.Visible then
					tween(stroke, {Transparency = 0}, TweenInfo.new(0.18))
				else
					tween(stroke, {Transparency = 0.8}, TweenInfo.new(0.18))
				end
			end)

			return {
				Frame = holder,
				SetOptions = function(newOptions, newDefault)
					options = newOptions or {}
					for _, c in ipairs(list:GetChildren()) do if c:IsA("TextButton") then c:Destroy() end end
					rebuild()
					if newDefault then btn.Text = tostring_safe(options[newDefault] or btn.Text) end
				end,
				GetValue = function() return btn.Text end
			}
		end

		-- CreateTextbox(text, placeholder, callback)
		function tabObj:CreateTextbox(labelText, placeholder, callback)
			labelText = tostring_safe(labelText or "Text")
			placeholder = tostring_safe(placeholder or "")
			local holder = Instance.new("Frame")
			holder.Size = UDim2.new(1, -24, 0, 44)
			holder.BackgroundTransparency = 1
			holder.Parent = Content

			local label = Instance.new("TextLabel", holder)
			label.Size = UDim2.new(0.5, 0, 1, 0)
			label.BackgroundTransparency = 1
			label.Text = labelText
			label.TextColor3 = Color3.fromRGB(230,230,230)
			label.Font = Enum.Font.Gotham
			label.TextSize = 14
			label.TextXAlignment = Enum.TextXAlignment.Left

			local box = Instance.new("TextBox", holder)
			box.AnchorPoint = Vector2.new(1,0.5)
			box.Position = UDim2.new(1, -12, 0.5, 0)
			box.Size = UDim2.new(0,220,0,32)
			box.BackgroundColor3 = Color3.fromRGB(22,22,28)
			box.BorderSizePixel = 0
			box.ClearTextOnFocus = false
			box.Text = ""
			box.PlaceholderText = placeholder
			box.Font = Enum.Font.Gotham
			box.TextSize = 14
			box.TextColor3 = Color3.fromRGB(220,220,220)
			Instance.new("UICorner", box).CornerRadius = UDim.new(0,6)
			local stroke = ApplyNeon(box); stroke.Transparency = 0.9

			box.Focused:Connect(function()
				tween(stroke, {Transparency = 0}, TweenInfo.new(0.14))
				tween(box, {Size = box.Size * UDim2.fromScale(1.002, 1.002)}, TweenInfo.new(0.12))
			end)
			box.FocusLost:Connect(function(enter)
				tween(stroke, {Transparency = 0.9}, TweenInfo.new(0.18))
				tween(box, {Size = box.Size}, TweenInfo.new(0.12))
				if enter and typeof(callback) == "function" then pcall(callback, box.Text) end
			end)

			return {
				Frame = holder,
				GetText = function() return box.Text end,
				SetText = function(v) box.Text = tostring_safe(v) end
			}
		end

		-- Return the created tab object
		return tabObj
	end

	-- Exposed window API
	local API = {}
	API.Window = Window
	API.CreateTab = function(self, a, b) return Window:CreateTab(a,b) end
	API.Destroy = function() if ScreenGui and ScreenGui.Parent then ScreenGui:Destroy() end end

	-- Callback if provided
	if typeof(Callback) == "function" then pcall(Callback) end

	return API
end

return KazeUI
